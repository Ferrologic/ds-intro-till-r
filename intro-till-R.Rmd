---
title: "Ferrologics Data Scientist Program"
subtitle: "Introduktion till R programmering"
author: "Zaida Liendeborg"
date: "14 augusti 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### R och RStudio

Plattformen som du ska arbeta i är RStudio. RStudio är en så kallad **IDE (Integrated Development Environment)** och programmeringsspråket heter R. 

I RStudio finns det fyra olika fönster: `Global Environment`, `File`, `Console`, `R script`.

1. Alla objekt som skapas i R sparas i **Global Environment**. Den finner du i den övre delen till höger av skärmen.

2. Fönstret i nedre delen till höger ser du **Files** där du hittar filerna som finns i din dator. Där kommer du också att se **plots**, **dokumentation om funktioner** och vilka **paket** som finns installerade.

3. Nere till vänster ser du din **Console** där du kan skriva och exekvera kod.

4. Ofast vill du dock kunna spara din kod, det går inte i din **Console**, istället kan du använda **R script** för att spara och enklare redigera din kod. **R script** öppnas per default uppe till höger i RStudio.

Ordningen på de olika fönstrena kan du själv ändra under `Tools -> Global Options -> Pane Layout`

### R som miniräknare

Liksom de flesta programmeringsspråk kan R användas som miniräknare.

1. Gör följande beräkningar i "Console"
```{r, eval=FALSE}
# Addition
2 + 2

# Subtraktion
10 - 8

# Multiplikation
10*10

#Division 
100/2

# Exponera
2^2 
2**2

```

2. Spara dina beräkningar som objekt
Du kan spara ovanstående beräkningar som `objekt` i R, dessa kan du senare använda. För att spara något till ett objekt använder du R:s `assignment operator` som är `<-`. Exempelvis:

```{r}
x <- 10*10
```

Du kan även spara flera värden i ett och samma objekt genom att skriva `c()` runt dina värden, då kallas objektet för en `vector`.

```{r}
x <- c(10*10, 100/2, 2^2)
```

Objekt kan inte bara innehålla numeriska värden utan även exempelvis text. 

```{r}
text <- c("hej", "jag", "älskar", "r", ":)")
```

### Funktioner
I R finns ett stort antal inbyggda statistiska funktioner.

Varje funktion följer principen:
```{r}
funktionens_namn(arg1 = val1, arg2 = val2, ...)
```

Prova att använda funktionen `mean()` på ditt objekt `x`.
```{r}
mean(x)
```

Vill du veta mer om en funktion kan du skriva `?mean()` i din **Console**, då kommer dokumentationen för funktionen upp.

## Paket
Funktioner i R är sparade i så kallade `packages`, `mean()` är exempelvis sparat i paketet `stats` som laddas automatiskt när du startar R. Styrkan i R ligger i dess alla olika paket. Du installerar paket med `install.packages("package")` och laddar dem med `library(paket)`. 

För att fortsätta med introduktionen kommer vi här använda oss av paketet `nycflights13` som innehåller data för alla flygplan som lämnade New York under 2013. 
```{r}
#install.packages("nycflights13")
library(nycflights13)
```

### Variabeltyper

Det finns olika variabeltyper i R och de vanligaste beskrivs i tabellen nedan.

Beskrivning    | Synonymer                     |  typeof() | Exempel
------------   | ----------------------------  | --------- | -------
Heltal         | int, numeric                  | integer   | -2, 0, 1
Reella tal     | real, double, float, numeric  | double    | 1.03, 0.22
Komplexa tal   | cplx                          | complex   | 1+2i
Logiska värden | booelan, bool, logi           | logical   | TRUE, FALSE
Faktorer       | factors                       | fctr      | "Women"
Datum          | dates                         | date      | "2017-02-04"
Text           | string, char                  | character | "Hello R!"

För att kika på data som finns i paketet du laddat kan du helt enkelt skriva namnet på data `flights` i din **Console**.

```{r}
flights
```

Här ser du enkelt vilka variabeltyper som finns i din data.

`flights` är en så kallad data.frame som egentligen är en samling vektorer. data.frame är den vanligaste data-typen i R och den vi kommer att arbeta med. 

Om du är nyfiken på att undersöka variabeltypen, eller klassen, på ett objekt eller en kolumn kan du använda funktionen **class()**

```{r}
class(x)
class(text)
```

#### Datamanipulering
Det sägs ofta att en Data Scientist ägnar 80% av sin tid till att manipulera data så att den går att visualisera och modellera. Därför är det klokt att välja en metod och ett paket som underlättar det arbetet för dig. 

I den här introduktionen kommer vi att fokusera på att använda paketet `dplyr` för att göra datamanipuleringar. `dplyr` är ett av de mest populära paketen i R och ger dig en bred verktygslåda för att manipulera data. `dplyr` ingår också i ett samlingspaket som heter `tidyverse` och samlar flertalet paket för datamanipulering, visualisering och modellering. 
`dplyr` har ett antal *verb*  för att göra manipuleringar. De som används mest är:
- filter() där du väljer observationer baserat på deras värden
- arrange() som ändrar ordningen på rader
- select() för att välja variabler baserat på deras namn
- mutate() för att skapa nya variabler baserat på funktioner
- summarise() för att summera många värden till ett värde

Samtliga av dessa verb kan användas i kombination med funktionen `group_by()` som innebär att du utför verben på flera grupper. 

Alla verb i `dplyr` är konsekventa. Det första argumentet är din data och i det andra argumentet specificerar du vad du vill göra med din data. Resultatet är alltid en ny data.frame. 

#### Filter
Med filter kan du enkelt filtrerar din data baserat på villkor. 

Dessa villkor uttrycks med hjälp av `logical operators`.

I R är dessa:

Operator | Symbol i R
-------- | ---------- 
och (and)|    &
eller(or)|    | 
icke(not)|    !

##### Relationsoperatorer
Man vill ofta jämföra olika vektorer för att sedan indexera en datamängd. Detta görs med hjälp av relationsoperatorer som beskrivs nedan.

Relationsoperatorer   |   Symbol i R
-------------------   | -------------
lika                  | ==
inte lika             | !=
större än eller lika  | >=
mindre än eller lika  | <=
större än             | >
mindre än             | <
finns i               | %in%

Dessa kan du använda i `filter()`.

PS: Det vanligaste misstaget i början av din R-karriär är att skriva `=` istället för `==`.

```{r}
library(dplyr)
filter(flights, month == 2, arr_time == 830)
```

För att använda relationsoperatorerna följer du samma princip.

```{r}
filter(flights, carrier %in% c("UA", "DL"), month == 2 | month == 3, dep_delay <= 0)
```

#### Missing values NA
Till en början kan det vara lite förvirrande att söka efter saknade värden i R, dessa representeras av `NA`. Då skriver man inte `filter(data, var == NA)` utan man skriver `filter(data, is.na(var))`. Det är för att `NA` inte är ett värde, det är ett saknat värde. En variabel måste ha ett värde för att du ska kunna utföra logiska operationer. Det kan kännas ologiskt (hehe) i början men det är en av R:s styrkor.

#### Arrange 
`arrange()` kastar om ordningen på dina rader enligt en av dig vald variabel. Exempelvis kanske vi vill sortera data på försenade avgångar `dep_delay`.

```{r}
arrange(flights, arr_delay)
```

`arrange()` sorterar per default på sjunkande värde (ascending). Vill du sortera på stigande värde (descending) sätter du `desc()` runt din variabel.

```{r}
arrange(flights, desc(dep_delay))
```

#### Select
Medan `arrange()` kastar om raderna så kastar `select()` om kolumnerna. Men mest används den för att välja kolumner av intresse.

```{r}
select(flights, dep_delay, carrier)
```

Om du av något skäl vill flytta en kolumn till början kan du skriva:

```{r}
select(flights, carrier, everything())
```

Du kan även välja alla kolumner mellan två kolumner:

```{r}
select(flights, year:day)
```

Genom att sätta ett minus framför variabelnamnet exkluderar du variabeln.

```{r}
select(flights, -year)
```

#### Mutate
`mutate()` används för att skapa nya variabler.

Exempelvis kan vi räkna ut hur mycket tid man vunnit om exempelvis flyget landar tidigare än avsett.

```{r}
mutate(flights, beer_time = dep_delay - arr_delay)
```

I `mutate()` kan du även använda funktioner såsom `mean()`. Men de kommer att bli mer vettiga i `summarise()`

```{r}
mutate(flights, mean_delay = mean(dep_delay, na.rm = T))
```
#### Summarise
Ofta vill man summera variabler för att få ut intressant information. Exempelvis vill vi här kanske veta en rad medelvärden.

```{r}
summarise(flights, 
          mean_air_time = mean(air_time, na.rm = T),
          mean_dep_delay = mean(dep_delay, na.rm = T),
          mean_arr_delay = mean(arr_delay, na.rm = T))
```

Men dessa värden är inte så intressanta i sig, utan vi vill kunna göra jämförelse. Då använder vi `group_by()`.

```{r}
group_by_flights <- group_by(flights, carrier)

summarise(group_by_flights, 
          mean_air_time = mean(air_time, na.rm = T),
          mean_dep_delay = mean(dep_delay, na.rm = T),
          mean_arr_delay = mean(arr_delay, na.rm = T))
```

I `summarise()` kan du använda en rad olika funktioner såsom `sum()` för summeringar, `median()` etc. 

#### Väv ihop verben med %>%

#### 1. Vektorer

Vektorer är ett objekt i R som innehåller en eller flera element. En vektor kan endast innehålla en typ av variabel. Det vanligaste sättet att skapa en vektor är genom **c()**. 

```{r}
# Numerisk vektor
numvec = c(1,4,7)

# Textvektor
charvec<- c("Kalle", "Anka")
```

#### 2. Faktorvariabel

En annan typ av variabel är den såkallade faktorer, *factor*. Faktorer är kategoriska variabler som har olika nivåer som representerar fakta. Kön eller åldersgrupp är exempel på faktorer.

```{r}
# minText är en textvektor
min_text <- c("A", "B", "A", "A")

# Konvertera minText till faktorvariabel med as.factor
min_faktor <- as.factor(min_text)

min_faktor

# För att undersöka klassen av vektorn minFaktor
class(min_faktor)

# För att undersöka vilka unika värden finns på minFaktor 
levels(min_faktor)
```

#### 3. Logik

Logiska värdena förekommer ofta i programmeringsvärlden. De logiska värdena i R är: **TRUE**, **FALSE** och **NA**. 

#### Logiska operatorer

Logiska operatorer är de operatorer som bara kan användas på logiska vektorer. Det kallas även för *boolsk algebra*. 

De viktigaste operatorerna i R visas i tabellen nedan. 

Operator | Symbol i R
-------- | ---------- 
och (and)|    &
eller(or)|    | 
icke(not)|    !

#### Relationsoperatorer

Man vill ofta jämföra olika vektorer för att sedan indexera en datamängd. Detta görs med hjälp av relationsoperatorer som beskrivs nedan.

1. Använder relationsoperatorer för att jämföra olika variabler. 
2. Relationsoperatorer returnerar logiska värde.
3. Logiska värdena används sedan för indexering. 

De vanligaste relationsoperatorer i R är följande:

Relationsoperatorer   |   Symbol i R
-------------------   | -------------
lika                  | ==
inte lika             | !=
större än eller lika  | >=
mindre än eller lika  | <=
större än             | >
mindre än             | <
finns i               | %in%

Nedan visas hur de används.

```{r}
# x är en numerisk vektor som innehåller värdena 1 till 15
x <- 1:15
x < 10

x != 5

x %in% c(1,2,7)

!(x == 10)
```


#### 4. Matriser

Matriser är också en av de vanligaste datastruktur i R. Den har två dimensioner, rader och kolumner. Likt som vektorer så kan matriser bara innehålla en typ av element. Det innebär att en matris kan endast vara en textmatris, numerisk matris eller logisk matris. 

Matriserna kan skapas enkelt i R med funktionen **matrix()**.

```{r}
minMatris <- matrix(data=c(1,2,3,4), nrow=2)
minMatris
```

Argumentet byrow = FALSE används i koden nedan. 
```{r}
minMatris2 <- matrix(data=c(1,2,3,4,5,6), nrow=3, byrow = FALSE)
minMatris2
```

Testa byta FALSE till TRUE. Hur ser matrisen ut då? 

#### 5. Data.frame

Data.frame är "data set" i R som används vanligtvis i analysfunktioner. Det är en stor tabell som innehåller ett antal variabel. Det är egentligen en samling av vektorer i R därför en data.frame kan innehålla olika typer av vektorer som numeriska, logiska, textsträngar och faktorer. 

För att skapa ett dataset i R används funktionen **data.frame()**

```{r}
minDF<- data.frame(num = 1:3, text = rep("Text", 3), logi=c(TRUE, TRUE, FALSE)) 
minDF
```

Det finns ett antal förinstallerade data.frame i R som du kan använda om du vill göra testanalyser eller för att träna koda i R.

För att kolla upp vilka data.frame som finns använd funktionen **data()**
```{r, eval=FALSE}
data()

# För att läsa in en data.frame i Global Environment så skriv namn av data inom parentesen
data(iris)
iris
```

#### Utforska en data.frame

Innan man utför en analys eller anpassa någon modell är det viktigt att utforska och undersöka vad man har för data först. Det finns ett antal funktioner som du kan använda för att få en bra känsla för din data. Testa att köra koder nedan. 

```{r, eval=FALSE}
# Funktioner head() och tail ()
head(iris)
tail(iris)

# Funktioner dim(), ncol(), nrow()
ncol(iris)
nrow(iris)
dim(iris)

# Funktioner summary() och str()
summary(iris)
str(iris)

# Funktioner names(), colnames() och rownames()
names(iris)
colnames(iris)
rownames(iris)
```

#### Skapa eller ta bort variabel

Ibland skapar man nya variabler utifrån andra variabler i en data.frame när man utför analyser. I R borde den nya variabeln ha samma längd som antalet rader.

Testa skapa ny variabel som produkten av Petal.Length och Sepal.Width genom att köra koden nedan.

```{r}
iris$nyVariabel<- iris$Petal.Length * iris$Sepal.Width

head(iris)
```

Prova skapa nya variabler med: 

1. Summan av *Sepal.Length* och *Sepal.Width*, namnge variablen som summan.
2. Kvoten av *Petal.Width* och *Petal.Length*, namnge variablen som kvoten.

#### Radera variabeln

För att radera en variabel i en data.frame: 

```{r}
iris$nyVariabel<- NULL
head(iris)
```

#### Ändra variabelnamn

Ibland vill man döpa om namnet på variabler i en data.frame för att det ska bli enkelt för en när man gör analyserna. 

För att ta reda på namn på variabler används funktionen *names()* eller *colnames()*

```{r}
colnames(iris)
```

Vill du ändra namn på variabler så gör du det på följande sätt: 

```{r}
# Ändra första variabeln
colnames(iris)[1] <- "Oj_EnVariabel"
colnames(iris)

# Ändra första och andra variabler
colnames(iris)[1:2] <- c("Sepal.Length", "Sepal_Width")
colnames(iris)

```


#### 6. Listor

Listor är mer generell datastruktur i R. Man kan jämföra lista med en "låda" som innehåller olika datastrukter i R. En lista kan innehålla vektorer, data.frame och matriser, i olika längd och storlek, samtidigt.

För att skapa en lista används funktionen **list()**

```{r}
# skapar vektorer a, b, c
a<- c("hej", "Kalle", "hejdå")
b<- c(TRUE, FALSE, FALSE, TRUE)
c<- 1:8

x<- list(a,b,c)
x
```

Ett mycket vanligt exempel på en lista är modellobjekt, dvs objektet man skapar när man anpassar en modell, till exempel en regressionsmodell. Hela resultatet från modellanpassningen ligger på en lista. Se nedan.

```{r}
# Skapar en data.frame
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)

# Linjär regression.
lm <- lm(weight ~ group)

is.list(lm)

# Vilka element eller objekt som finns i listan lm? 
attributes(lm)

```

lm är en lista som innehåller bland annat regressions koefficienter, residualer, anpassade värden, mm.


### Datum

I R uttrycks datum som antal dagar från 1970-01-01. Datum som kommer innan det skrivs ut som negativa värde. 

```{r }
minaDatum <- as.Date(c("2018-08-14", "1970-01-01"))

minaDatum[1] - minaDatum[2]


as.Date(17757, origin = "1970-01-01")
```

**Sys.Date()** ger dagens datum.
**date()** returnerar dagens veckodag, datum och tid.

#### Olika dataformat 

Symbol i R | Betydelse          | Exempel
-----------|------------------- | --------
%d	       | dagnummer          |	01-31
%a         | förkortad veckodag | Mon
%A	       | full veckodag      | Monday 
%m	       | månad nummer       | 00-12
%b         | förkortad månad    | Jan
%B	       | full månad         | January
%y         | 2 siffrig år       | 18
%Y	       | 4 siffrig år       | 2018

#### Formatera datum 

```{r}
idag <- Sys.Date()

format_idag <- format(idag, format = "%B %d %Y")
format_idag

format(minaDatum[2], format="%m/%d/%y")
```


### Indexering

Ibland är man bara intresserad av en kolumn eller enstaka värde. För att indexera eller plocka ut specifikt element ur ett objekt kan man använda sig av hackparentes [] eller dollar tecken $ och detta görs på olika sätt.

#### 1. Genom att ange positions nummer

```{r }
#Vektor
testScore <- c(7, 15, 20, 20, 23, 1.2)
testScore[3] #tredje element
testScore[-1] #alla utom den första
```

Kör koden nedan för att se resultatet.

```{r, eval = FALSE }

#Data.frame.
data(iris)
iris[, 1] # Väljer kolumn nummer 1
iris[1:5, c(1,2)] # Rad 1 till 5 på Kolumn 1 och 2

```

#### 2. Genom att begränsa värden som man vill plocka ut 


```{r }
# Vektor
testScore[testScore < 10] # alla som är mindre än 10
testScore[testScore == 20] # alla som är lika med 20
```

Kör koden nedan för att se resultatet.

```{r, eval = FALSE }

# Data.frame
head(iris[iris[,1] > 7,]) # alla observationer där kolumn nummer 1 är större än 7. Funktionen head() används för att minimera rader som skrivs ut. 
```

#### 3. Genom att ange namn av elementet eller kolumnen

Det går att namnge element i en vektor. Koder nedan visar hur man ger namn till varje element i en vektor. Efter att ha namngett vektorn kan du nu plocka ut värde med hjälp av namn. 

```{r }
# Sätter namn på respektive element i testScore
names(testScore)<- c("Zaida", "Anna", "Helena", "Per", "Filip", "Annelie")
testScore
testScore["Per"]
testScore["Filip"]

# Kolumnen i en data.frame oftast har namn. Objekt som har 2 eller mer dimensioner kan vi använda oss av dollar tecken.   
colnames(iris)
```

Kör koden nedan för att se resultatet.

```{r, eval = FALSE }

iris$Sepal.Length
iris[, "Sepal.Length"]

```

### Sortering

Skulle du behöva sortera element i din vektor så kan du använda funktioner **sort()** eller **order()**. Eller sortera din data.frame baserad på en kolumn kan du använda funktionen **order()**. **sort()** returnerar sorterade värdena medan **order()** returnerar indexer av värdena. Se exempel kod nedan.

```{r}
vektor<- c(15, 12, 14, 13,-11)
sort(vektor, decreasing = FALSE)
sort(vektor, decreasing = TRUE)

order(vektor, decreasing=FALSE) #returnerar indexer 
order(vektor, decreasing=TRUE)

head(iris[order(iris$Sepal.Length, decreasing=TRUE),])
```


### Grundläggande databearbetning.

Oftast så är databearbetning som tar längst tid när vi gör analyser. Det finns antal bas funktioner i R som är användbara när vi bearbetar data. 

I den här delen fokuserar vi bara på funktioner i base R. De vanligaste funktioner visas i tabellen nedan. 

Funktion    |   Beskrivning
---------   | --------------
rbind()     | Kombinerar data.frames radvis
cbind()     | Kombinerar data.frames kolumnvis
merge()     | Sammanfogar två data.frames med en ID-variabel
aggregate() | Aggregerar uppgifter efter en ID-variabel

#### 1. Kombinera data.frames med rbind() och cbind()

Funktionerna **rbind()** och **cbind()** kräver att data.frame ska vara lika långa. Ska man kombinera data radvis borde antal kolumner vara lika. Att kombinera data kolumnvis med cbind() borde antal rader vara lika mellan två data.frame.

Börja med att läsa in data.frame iris och sedan dela den i två delar för att få två olika data.frame med samma storlek

```{r}
data(iris)

head_iris <- head(iris)
tail_iris<- tail(iris)

# Kombinera kolumnvis
column<- cbind(head_iris, tail_iris)
column

# Kombinera radvis
rad<- rbind(head_iris, tail_iris)
rad
```

#### 2. Sammanfogar data.frame med merge()

För att göra det enkelt kan du använda exempel data från funktionen **merge()**.  Kör koden nedan för att läsa in dem: 

```{r}
example("merge", echo = FALSE)
```

Nu har du fått två olika data.frame som heter **authors** och **books**. De är sparade i Global Environment. De tre första raderna av data.frame visas nedan. 

```{r, echo=FALSE}
head(authors, n=3)
head(books, n=3)
```

Prova nu att sammanfoga **authors** och **books** med koden nedan. Kolumner "surname" och "name" från authors respektive books innehåller  egentligen samma information. Detta innebär att surname och name kan användas som ID variabel och eftersom de har olika namn så måste de specifieras i merge funktionen. 
```{r}
res1 <- merge(x=authors, y=books, by.x = "surname", by.y = "name")
res1
```

#### Aggregera data med aggregate()

Ibland behöver man aggregera delar av data. Detta kan göras enkelt med funktionen aggregate().

I funktionen aggregate() behöver du ange vilken variabel du vill aggregera på, efter vilken ID variabel samt vilken funktion ska användas för aggregering. Se koden nedan.

```{r}
data(iris) 

agg <- aggregate(x=iris$Sepal.Length, by=list(iris$Species), FUN=mean, rm.na=TRUE) #rm.na = TRUE tar bort alla missing values eller NA
agg
```

### Databearbetning och utforskning med dplyr

Det finns också ett antal paket som gör att databearbetning i R blir väldigt smidigt, exempelvis paketet **dplyr**. Detta beror delvis på **pipe** operator, **%>%**, som funkar som kedja och kopplar ihop koder. Det är väldigt effektivt om man ska göra ett antal databearbetningsprocess utan att spara varje steg. Det gör också att det blir lättare att följa upp vad som händer i varje steg.  


I nedre exemplet ska vi använda några av de vanligaste funktioner i dplyr paketet. Återigen använder vi iris data för att testa följande funktionerna.


#### 1. Skapa eller radera variabler

**mutate()** används för att skapa nya variabler i data.frame. **transmute()** är för att droppa existerande variabler och behåller endast den nya variabeln du skapade.

```{r, message=FALSE}
library(dplyr)
```

```{r}
data(iris)

# mutate
mutate_iris<- iris %>% 
  mutate(Sepal.Length2 = Sepal.Length ** 2)
head(mutate_iris)

# transmute
transmute_iris<- iris %>% 
  transmute(Sepal.Length2 = Sepal.Length ** 2)
head(transmute_iris)
```

#### 2. Filtrera
**filter()** funktionen används för att filtrera data enligt någon villkor du vill. 
```{r}
data(iris) 

setosa <- filter(iris, Species == "setosa") 
head(setosa) # använde head() för att begränsa resultatet som skrivs ut.
```


#### 3. Aggregering och gruppering

**summarise()** funkar som funktionen aggregate(). **group_by** används om vi vill undersöka data per grupp. 

```{r}
# Aggregera på medelvärde
iris %>% 
  summarise(mean = mean(Petal.Width), n=n()) # n() ger oss antal observationer.

# Aggregerade data per Speices

iris %>% 
  group_by(Species) %>%
  summarise(mean = mean(Petal.Width), median = median(Sepal.Width),  n=n())

```

### Exempel på vanlig databearbetning med dplyr 

1. Läs in data. 
2. Skapa ny variabel.
3. Transformera för att få den önskade fördelningen. Detta beror på vilken statistik metod man använder.
4. Ta bort eller imputera saknade värde.

```{r, eval=FALSE}
# Kör koden nedan i din RStudio för att se resultatet.
iris %>%
  # Nya variabler och transformering genom log()
  mutate(Sepal.Length.Width = Sepal.Length*Sepal.Width, Log.Petal.Width = log(Petal.Width)) %>% 
  #na.omit() %>%  # Vill du ta bort alla saknade värde då kan du köra denna funktion. 
   # om det finns saknade värde i kolumnen Sepal.Length imputera vi dem till medelvärde
  mutate(Sepal.Length = ifelse(is.na(Sepal.Length), mean(Sepal.Length), Sepal.Length))
 
```


Det finns fler funktioner inom paketet dplyr som är väldigt användbar i data utforskning och bearbetning. Här kommer en länk till dplyr paket dokumentation. Du finner olika funktioner och exempel på hur man kan använda dem i ditt arbete: https://www.rdocumentation.org/packages/dplyr/versions/0.5.0

### Filhantering

När man arbetar med R använder man alltid en *working directory* eller sökväg.

1. För att ta reda på vilken sökväg du arbetar på används funktionen getwd()

```{r, eval=FALSE}
getwd()
```

2. För att sätta upp sökvägen kan du använda funktionen setwd()

```{r, eval=FALSE}
setwd("sökvägen")
```

3. Med funktionen dir() kan du se vilka filer som finns i din nuvarande sökvägen. 

```{r, eval=FALSE}
dir()
```

### Input

Det är inte ofta man arbetar med de förinstallerade data.frame som finns i R. Det är vanligare att man behöver läsa in en extern fil till RStudio. Det kan du göra med flera olika funktioner beroende på typ av fil du ska använda. De vanligaste typer av filer är csv, txt eller excel filer. 

För att läsa in csv och text filer så finns det read.csv() respektive read.table(). 

```{r, eval=FALSE}
# Om filen är en text fil
lemon <- read.table(file="lemon.txt", sep=";", header=TRUE)

# Om file är en csv fil
apple <- read.csv(file="Apple.csv", sep=";", header=TRUE)
```


### Output

När du är klar med databearbetning, alltså när data är redo för analys eller bygga en modell vill man oftast spara den i lokala disken så att man inte behöver repetera hela databearbetningsprocess.

För att spara data.frame i lokal disken kan man använda funktioner write.csv() och write.table() om du vill spara dem som csv respektive text fil. Filerna hamnar då i den nuvarande sökvägen.

```{r, eval=F}
#csv-fil
write.csv(apple, file="Apple.csv")

#text fil
write.table(lemon, file="lemon.txt")

```

För att hantera excel filer krävs det att installera paket. Ett exempel på ett paket som kan hantera excel filer är paketet **xlsx**.

### Paket inläsning

I R finns det tusentals paket som är skrivna av R experter för att göra arbetet i R så smidigt som möjligt. Paketet är Open Source, vilket betyder att vem som helst kan ta del av det. För att se vilka paket som finns installerade i din dator kan man bläddra under fönstret **Packages**.

För att installera ett paket och sedan läsa in det i RStudio, se exempel kod nedan. 

Package MASS har ett antal funktioner som man kan använda för statistiska analyser.

```{r, eval=F}
# Installera paket MASS
install.packages("MASS")
```

När installationen är färdig måste paketet vara inläst i RStudio innan du kan använda det. Det gör du enkelt med:

```{r, eval=F}
library(MASS)
```


#### Referenser:

https://www.r-bloggers.com/data-manipulation-with-dplyr/
https://www.statmethods.net/input/dates.html



